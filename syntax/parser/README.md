Except for `parser.go`, all other .go files in this directory is generated by Antlr and should not be modified by humans. 

`parser.go` contains the implementation for visitor methods to build an AST from Antlr's concrete syntax tree and `ast.go` structs/interfaces. The general process is as follow: 

1. Locate the relevant items in grammar and `ast.go`. For example, this rule in the grammar

```
program
    : declaration* EOF
    ;
```

corresponds to this struct in `ast.go`:

```
type Program struct {
	BaseNode
	Declarations []Declaration
}
```

and now we need to implement their corresponding visitor method in `parser.go`:

```
func (v *ASTBuilder) VisitProgram(ctx *ProgramContext)
```

2. Find the common tokens and populate the data in these fields first 

Consider this rule: 
```
declaration
    : type arrayNotation? Identifier declarationRemainder
    ;
```

Which could have been a regular variable declaration or an array declaration. The first step is to process the common `type` token first, after this is done, consume the next token and decide if it is an array declaration. 

3. Branching 

When standing at a decision point (ie. after processing `type` and have to decide if this is an array declaration), proceed to process each case using if-else. 

This is when grammar unambiguity proves to be very useful: if the grammar is ambiguous, you would need to implement lookahead logic to lookahead several tokens to have enough information to keep going. 

Once again, this is very formulaic and requires detailed handling. 

## Helpful resources 
- [This guy](https://youtu.be/VKM1eLoN-gI?si=WzVZjmnYIZWEjvEG) explains and demonstrates CST, AST, and happen to also explain interpreting vs. compiling pretty well in the process. He uses lex/yacc though, so if you're only familiar with Antlr it takes some extra effort to learn lex/yacc.